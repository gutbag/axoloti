<objdefs appVersion="1.0.12">
   <obj.normal id="TapTempo" uuid="623eb61e-59ba-4b39-92cf-9165c1dd97ea">
      <sDescription>Receives tap trigger inputs and adjusts the timing of an output trigger to match. No output unless enabled and output sync&apos;d to enable edge.</sDescription>
      <author>Mark Lamb</author>
      <license>GPL</license>
      <inlets>
         <bool32.rising name="tap" description="the tap input"/>
         <bool32.rising name="enable"/>
      </inlets>
      <outlets>
         <bool32.pulse name="trigger"/>
      </outlets>
      <displays/>
      <params/>
      <attribs/>
      <code.declaration><![CDATA[static const uint32_t MAX_K_PER_TAP = 1500 * 3; // 1.5s tap timeout
static const uint32_t TAP_DELAY_ADJUSTMENT_MS = 0;
static const uint32_t TAP_DELAY_ADJUSTMENT_K = TAP_DELAY_ADJUSTMENT_MS * 3; // 3 Ks/ms
static const uint8_t MAX_TAPS = 10;

uint32_t kPerTrigger = 1 * 3000; // default 60BPM i.e. 1 trig/s
bool kPerTriggerChanged = false;
uint32_t currentKCount = kPerTrigger;

bool tapping = false;
uint32_t kCountSinceTap = 0;
uint32_t kCounts[MAX_TAPS];
uint8_t kCountsIndex = 0;

bool enabled = false;

uint32_t calcAverage(const uint32_t values[], const uint8_t numValues)
{
	uint32_t sum = 0;
	for (uint8_t i=0; i<numValues; i++)
		sum += values[i];
	return sum/numValues;
}]]></code.declaration>
      <code.krate><![CDATA[outlet_trigger = 0;

if (inlet_enable)
{
	enabled = true;
	outlet_trigger = 1; // first trigger immediately
	currentKCount = kPerTrigger; // restart count
	LogTextMessage("tempo triggers enabled\n");
}

if (enabled)
{
	if (currentKCount == 0)
	{
		outlet_trigger = 1;
	
		currentKCount = kPerTrigger; // restart count
	
		if (kPerTriggerChanged) // first trigger after adjustment - allow for delay
		{
			kPerTriggerChanged = false;
			
			if (currentKCount > TAP_DELAY_ADJUSTMENT_K)
			{
				LogTextMessage("Adjusting currentKCount from %u to %u\n", currentKCount, currentKCount - TAP_DELAY_ADJUSTMENT_K);
				// bring first trigger forward to allow for delay
				currentKCount -= TAP_DELAY_ADJUSTMENT_K;
			}
			else
			{
				LogTextMessage("ERROR: could not adjust currentKCount %u by TAP_DELAY_ADJUSTMENT_K %u\n", currentKCount, TAP_DELAY_ADJUSTMENT_K);
			}
		}
	}
	
	currentKCount--;
}

if (tapping)
{
	kCountSinceTap++;

	if (kCountSinceTap > MAX_K_PER_TAP) // timeout
	{
		tapping = false;
		// apply delay adjustment now that we know tapping has finished
		kPerTriggerChanged = true;
	}
}

if (inlet_tap > 0) // got a tap
{
	if (tapping)
	{
		// store the k count as the new tap delay
		//kPerTrigger = kCountSinceTap;
		kCounts[kCountsIndex] = kCountSinceTap;
		kCountsIndex++;
		if (kCountsIndex >= MAX_TAPS)
		{
			tapping = false;
		}
		//LogTextMessage("kCountSinceTap %u/%ums\n", kCountSinceTap, kCountSinceTap/3);
		kPerTrigger = calcAverage(kCounts, kCountsIndex);
		LogTextMessage("kPerTrigger %u/%ums\n", kPerTrigger, kPerTrigger/3);
	}
	else // the first tap
	{
		tapping = true;
		kCountsIndex = 0;
	}

	// restart the counter
	kCountSinceTap = 0;
}]]></code.krate>
   </obj.normal>
</objdefs>