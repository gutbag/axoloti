<objdefs appVersion="1.0.12">
   <obj.normal id="looper_153BPM_8bars_overdub_v2" uuid="010efc20-bbd5-4d66-bdbc-e73c64c6b0d0">
      <sDescription>Moagulum main theme argpeggios + overdubbed hocket section. Records 8 bars then overdubs 8 bars then plays repeatedly. Version 2 has direct MIDI trigger and knows the Moagulum states.</sDescription>
      <author>Mark Lamb</author>
      <license>GPL</license>
      <inlets>
         <frac32buffer name="in" description="wave input"/>
         <frac32buffer name="overdub"/>
         <bool32.rising name="trigger"/>
         <bool32.rising name="reset"/>
      </inlets>
      <outlets>
         <frac32buffer name="out"/>
         <bool32 name="recording"/>
         <bool32 name="overdubbing"/>
         <bool32 name="playing"/>
      </outlets>
      <displays>
         <bool32 name="reset"/>
         <bool32 name="recording"/>
         <bool32 name="overdubbing"/>
         <bool32 name="playing"/>
         <bool32 name="readyToPlay"/>
      </displays>
      <params/>
      <attribs/>
      <code.declaration><![CDATA[static const uint32_t BPM = 153;
static const uint32_t BARS = 8;
static const uint32_t BEATS_TO_BAR = 4;
static const uint32_t BEATS = BARS * BEATS_TO_BAR;
static constexpr double SAMPLE_PERIOD = 1.0 / 48000.0;
static const uint32_t LENGTH = ((60.0 / BPM) * BEATS) / SAMPLE_PERIOD;

int32_t* array;
uint32_t writepos;
uint32_t readpos;

typedef enum {INIT, RESET, RECORDING, OVERDUBBING, PLAYING, READY_TO_PLAY} State;
State state;

typedef enum {NONE, START_RECORDING, PLAY, STOP, CLEAR} Event;
Event event;

void clearArray()
{
	for (int i=0; i<LENGTH; i++)
		array[i] = 0;
}]]></code.declaration>
      <code.init><![CDATA[static int32_t _array[LENGTH] __attribute__ ((section (".sdram")));
array = &_array[0];

clearArray();

writepos = 0;
readpos = 0;

state = INIT;
event = NONE;

//LogTextMessage("Init looper_153BPM_8bars_overdub_v2\n");]]></code.init>
      <code.krate><![CDATA[if (inlet_reset && state != RESET)
{
	//LogTextMessage("CLEAR\n");
	event = CLEAR;
}
else if (inlet_trigger && state == RESET)
{
	//LogTextMessage("START_RECORDING\n");
	event = START_RECORDING;
}
else if (inlet_trigger && (state == RECORDING || state == OVERDUBBING || state == PLAYING))
{
	//LogTextMessage("STOP\n");
	event = STOP;
}
else if (inlet_trigger && state == READY_TO_PLAY)
{
	//LogTextMessage("PLAY\n");
	event = PLAY;
}]]></code.krate>
      <code.srate><![CDATA[switch (state)
{
	case INIT: // entered only once on startup
		state = RESET;
	break;
	case RESET: // wait to start recording
		switch (event)
		{
			case START_RECORDING:
				state = RECORDING;
				writepos = 0;
			break;
			case PLAY:
				// ignore
			break;
			case STOP:
				// ignore
			break;
			case CLEAR:
				// ignore
			break;
			case NONE:
				outlet_out = 0; // no output
			break;
		}
	break;
	case RECORDING: // record until full then overdub
		switch (event)
		{
			case START_RECORDING:
				// ignore
			break;
			case PLAY:
				// ignore
			break;
			case STOP: // stop and clear handled together
			case CLEAR:
				state = RESET;
			break;
			case NONE:
				array[writepos] = inlet_in;
				outlet_out = 0; // no output
				++writepos;
				if (writepos >= LENGTH)
				{
					state = OVERDUBBING; // go to this state directly
					writepos = 0;
				}
			break;
		}
	break;
	case OVERDUBBING: // overdub until full then play
		switch (event)
		{
			case START_RECORDING:
				// ignore
			break;
			case PLAY:
				// ignore
			break;
			case STOP:
			case CLEAR:
				state = RESET;
			break;
			case NONE:
				outlet_out = array[writepos]; // copy previous sample to output
				array[writepos] = __SSAT(inlet_overdub + array[writepos], 28); // mix with existing value in array
				++writepos;
				if (writepos >= LENGTH)
				{
					state = PLAYING; // go to this state directly
					readpos = 0;
				}
			break;
		}
	break;
	case PLAYING: // keep playing until stopped
		switch (event)
		{
			case START_RECORDING:
				// ignore
			break;
			case PLAY:
				// ignore
			break;
			case STOP:
				state = READY_TO_PLAY;
			break;
			case CLEAR:
				state = RESET;
			break;
			case NONE:
				outlet_out = array[readpos];
				++readpos;
				if (readpos >= LENGTH) // for now, repeat loop forever
					readpos = 0;
			break;
		}
	break;
	case READY_TO_PLAY: // already got audio
		switch (event)
		{
			case START_RECORDING:
				// ignore
			break;
			case PLAY:
				state = PLAYING;
				readpos = 0;
			break;
			case STOP:
				// ignore
			break;
			case CLEAR:
				state = RESET;
			break;
			case NONE:
				outlet_out = 0; // no output
			break;
		}
	break;
}

// consume the event
event = NONE;

// update the displays and output flags
switch (state)
{
	case INIT: // shouldn't happen, we go straight to reset
		disp_reset = 0;
		outlet_recording = 0;
		disp_recording = 0;
		outlet_overdubbing = 0;
		disp_overdubbing = 0;
		outlet_playing = 0;
		disp_playing = 0;
		disp_readyToPlay = 0;
	break;
	case RESET:
		disp_reset = 1;
		outlet_recording = 0;
		disp_recording = 0;
		outlet_overdubbing = 0;
		disp_overdubbing = 0;
		outlet_playing = 0;
		disp_playing = 0;
		disp_readyToPlay = 0;
	break;
	case RECORDING:
		disp_reset = 0;
		outlet_recording = 1;
		disp_recording = 1;
		outlet_overdubbing = 0;
		disp_overdubbing = 0;
		outlet_playing = 0;
		disp_playing = 0;
		disp_readyToPlay = 0;
	break;
	case OVERDUBBING:
		disp_reset = 0;
		outlet_recording = 0;
		disp_recording = 0;
		outlet_overdubbing = 1;
		disp_overdubbing = 1;
		outlet_playing = 0;
		disp_playing = 0;
		disp_readyToPlay = 0;
	break;
	case PLAYING:
		disp_reset = 0;
		outlet_recording = 0;
		disp_recording = 0;
		outlet_overdubbing = 0;
		disp_overdubbing = 0;
		outlet_playing = 1;
		disp_playing = 1;
		disp_readyToPlay = 0;
	break;
	case READY_TO_PLAY:
		disp_reset = 0;
		outlet_recording = 0;
		disp_recording = 0;
		outlet_overdubbing = 0;
		disp_overdubbing = 0;
		outlet_playing = 0;
		disp_playing = 0;
		disp_readyToPlay = 1;
	break;
}]]></code.srate>
   </obj.normal>
</objdefs>